import type { Vec3 } from './types';
import type { GeneratedMesh } from './mesh-generator';
import { calculateNormal } from './mesh-generator';

/**
 * Export mesh to binary STL format
 * Binary STL is more compact than ASCII
 */
export function exportToBinarySTL(mesh: GeneratedMesh): ArrayBuffer {
  const { triangles } = mesh;
  
  // Binary STL format:
  // 80 bytes: header
  // 4 bytes: number of triangles (uint32)
  // For each triangle (50 bytes):
  //   12 bytes: normal vector (3 x float32)
  //   12 bytes: vertex 1 (3 x float32)
  //   12 bytes: vertex 2 (3 x float32)
  //   12 bytes: vertex 3 (3 x float32)
  //   2 bytes: attribute byte count (uint16, usually 0)

  const bufferSize = 80 + 4 + triangles.length * 50;
  const buffer = new ArrayBuffer(bufferSize);
  const view = new DataView(buffer);

  // Write header (80 bytes of zeros/text)
  const header = 'Binary STL generated by depthmap-to-stl';
  for (let i = 0; i < 80; i++) {
    view.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
  }

  // Write triangle count
  view.setUint32(80, triangles.length, true); // little-endian

  // Write triangles
  let offset = 84;
  for (const tri of triangles) {
    const normal = calculateNormal(tri);

    // Normal
    view.setFloat32(offset, normal.x, true); offset += 4;
    view.setFloat32(offset, normal.y, true); offset += 4;
    view.setFloat32(offset, normal.z, true); offset += 4;

    // Vertex 1
    view.setFloat32(offset, tri.v1.x, true); offset += 4;
    view.setFloat32(offset, tri.v1.y, true); offset += 4;
    view.setFloat32(offset, tri.v1.z, true); offset += 4;

    // Vertex 2
    view.setFloat32(offset, tri.v2.x, true); offset += 4;
    view.setFloat32(offset, tri.v2.y, true); offset += 4;
    view.setFloat32(offset, tri.v2.z, true); offset += 4;

    // Vertex 3
    view.setFloat32(offset, tri.v3.x, true); offset += 4;
    view.setFloat32(offset, tri.v3.y, true); offset += 4;
    view.setFloat32(offset, tri.v3.z, true); offset += 4;

    // Attribute byte count
    view.setUint16(offset, 0, true); offset += 2;
  }

  return buffer;
}

/**
 * Export mesh to ASCII STL format
 * More human-readable but larger file size
 */
export function exportToASCIISTL(mesh: GeneratedMesh): string {
  const { triangles } = mesh;
  const lines: string[] = [];

  lines.push('solid depthmap');

  for (const tri of triangles) {
    const normal = calculateNormal(tri);
    lines.push(`  facet normal ${formatFloat(normal.x)} ${formatFloat(normal.y)} ${formatFloat(normal.z)}`);
    lines.push('    outer loop');
    lines.push(`      vertex ${formatFloat(tri.v1.x)} ${formatFloat(tri.v1.y)} ${formatFloat(tri.v1.z)}`);
    lines.push(`      vertex ${formatFloat(tri.v2.x)} ${formatFloat(tri.v2.y)} ${formatFloat(tri.v2.z)}`);
    lines.push(`      vertex ${formatFloat(tri.v3.x)} ${formatFloat(tri.v3.y)} ${formatFloat(tri.v3.z)}`);
    lines.push('    endloop');
    lines.push('  endfacet');
  }

  lines.push('endsolid depthmap');

  return lines.join('\n');
}

function formatFloat(n: number): string {
  return n.toExponential(6);
}

/**
 * Trigger download of the STL file
 */
export function downloadSTL(
  mesh: GeneratedMesh,
  filename: string = 'depthmap.stl',
  binary: boolean = true
): void {
  let blob: Blob;
  
  if (binary) {
    const buffer = exportToBinarySTL(mesh);
    blob = new Blob([buffer], { type: 'application/octet-stream' });
  } else {
    const ascii = exportToASCIISTL(mesh);
    blob = new Blob([ascii], { type: 'text/plain' });
  }

  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Get mesh statistics
 */
export function getMeshStats(mesh: GeneratedMesh): {
  triangleCount: number;
  estimatedFileSizeMB: number;
  boundingBox: { min: Vec3; max: Vec3 };
} {
  const { triangles } = mesh;

  const min: Vec3 = { x: Infinity, y: Infinity, z: Infinity };
  const max: Vec3 = { x: -Infinity, y: -Infinity, z: -Infinity };

  for (const tri of triangles) {
    for (const v of [tri.v1, tri.v2, tri.v3]) {
      min.x = Math.min(min.x, v.x);
      min.y = Math.min(min.y, v.y);
      min.z = Math.min(min.z, v.z);
      max.x = Math.max(max.x, v.x);
      max.y = Math.max(max.y, v.y);
      max.z = Math.max(max.z, v.z);
    }
  }

  // Binary STL: 80 header + 4 count + 50 per triangle
  const binarySize = 80 + 4 + triangles.length * 50;

  return {
    triangleCount: triangles.length,
    estimatedFileSizeMB: binarySize / (1024 * 1024),
    boundingBox: { min, max },
  };
}
