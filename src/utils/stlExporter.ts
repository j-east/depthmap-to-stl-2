import { MeshData } from '../types';

export function exportSTL(meshData: MeshData, filename: string = 'model.stl'): void {
  const stlString = generateBinarySTL(meshData);
  const blob = new Blob([stlString], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();

  URL.revokeObjectURL(url);
}

export function generateBinarySTL(meshData: MeshData): ArrayBuffer {
  const { vertices, indices } = meshData;
  const triangleCount = indices.length / 3;

  // Binary STL format:
  // 80 byte header
  // 4 byte triangle count (uint32)
  // For each triangle:
  //   - 12 bytes: normal vector (3 x float32)
  //   - 36 bytes: 3 vertices (3 x 3 x float32)
  //   - 2 bytes: attribute byte count (uint16)

  const bufferSize = 80 + 4 + triangleCount * 50;
  const buffer = new ArrayBuffer(bufferSize);
  const view = new DataView(buffer);

  // Write header (80 bytes)
  const header = 'Binary STL generated by depth-map-to-stl';
  for (let i = 0; i < 80; i++) {
    view.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
  }

  // Write triangle count
  view.setUint32(80, triangleCount, true);

  let offset = 84;

  // Write triangles
  for (let i = 0; i < triangleCount; i++) {
    const i0 = indices[i * 3];
    const i1 = indices[i * 3 + 1];
    const i2 = indices[i * 3 + 2];

    const v0 = [vertices[i0 * 3], vertices[i0 * 3 + 1], vertices[i0 * 3 + 2]];
    const v1 = [vertices[i1 * 3], vertices[i1 * 3 + 1], vertices[i1 * 3 + 2]];
    const v2 = [vertices[i2 * 3], vertices[i2 * 3 + 1], vertices[i2 * 3 + 2]];

    // Calculate normal
    const normal = calculateNormal(v0, v1, v2);

    // Write normal (12 bytes)
    view.setFloat32(offset, normal[0], true);
    view.setFloat32(offset + 4, normal[1], true);
    view.setFloat32(offset + 8, normal[2], true);
    offset += 12;

    // Write vertices (36 bytes)
    view.setFloat32(offset, v0[0], true);
    view.setFloat32(offset + 4, v0[1], true);
    view.setFloat32(offset + 8, v0[2], true);
    view.setFloat32(offset + 12, v1[0], true);
    view.setFloat32(offset + 16, v1[1], true);
    view.setFloat32(offset + 20, v1[2], true);
    view.setFloat32(offset + 24, v2[0], true);
    view.setFloat32(offset + 28, v2[1], true);
    view.setFloat32(offset + 32, v2[2], true);
    offset += 36;

    // Write attribute byte count (2 bytes)
    view.setUint16(offset, 0, true);
    offset += 2;
  }

  return buffer;
}

function calculateNormal(
  v0: number[],
  v1: number[],
  v2: number[]
): [number, number, number] {
  // Calculate two edge vectors
  const edge1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
  const edge2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];

  // Calculate cross product
  const normal = [
    edge1[1] * edge2[2] - edge1[2] * edge2[1],
    edge1[2] * edge2[0] - edge1[0] * edge2[2],
    edge1[0] * edge2[1] - edge1[1] * edge2[0],
  ];

  // Normalize
  const length = Math.sqrt(
    normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]
  );

  if (length > 0) {
    normal[0] /= length;
    normal[1] /= length;
    normal[2] /= length;
  }

  return normal as [number, number, number];
}
